#### 万年不变学生表
#####  有两张表，学生表（student）和分数表（grade）
##### 题目1：查询所有学生的数学成绩，显示学生姓名name,分数，由高到低
`
select a.name,b.score 
from student a,grade b 
where a.id=b.id and kemu='数学`
order by score desc

`
> order by 行的排序，默认为升序，order by 后面必须列出排序的字段名，可以是多个字段名    
> group by 比order by先执行，order by不会对group by 内部进行排序，如果group by后只有一条记录，那么order by 将无效。要查出group by中最大的或最小的某一字段使用 max或min函数 
> order by原则，写在最前面的字段，优先级最高
##### 题目2：统计每个学生的总成绩sum，显示字段：姓名，总成绩
`
select a.name,sum(b.score) 
from student a,grade b
where a.id = b.id
group by name desc
`
> group by 分组，必须是聚合函数来配合才使用，使用时至少需要一个分组标志字段
> group by 根据一个或多个列对结果集进行分组，在分组的列上可以使用count，sum,avg等函数
> count函数与sum函数：count()主要用来统计表的行数；sum()用来求表中某一字段数据的和，即某一列的和 
> where函数后不能接聚合函数；聚合函数是根据结果集进行的，但是where条件并不是在查询出结果集之后运行，采用另一种having
##### 题目3：统计每个学生的总成绩（由于学生可能有重复名字）,显示字段：学生 id，姓名，总成绩

`
select a.id,a.name,c.sum_score
from student a,
(select b,id,sun(b.score) as sum_score
from grade b
group by id
)c
where a.id = c.id
order by sum_score desc

`
#### 关于where和having
> group by可以跟where使用，where在group by之前
> having 只能用在group by 之后，对分组后的结果进行筛选（即使用having的前提是分组）   
> where 后的条件表达式里不允许使用聚合函数，having可以

`
select product,sum(price) from orders GROUP BY product HAVING sum(price)>100
select product,sum(price) from orders GROUP BY product HAVING sum(price)>100 ORDER BY sum(price)

`
##### 题目4：统计单科最好成绩,列出各门课程成绩最好的学生， 要求显示字段: 学号，姓名,科目，成绩
```
# 第一步先group by 找出单科最好成绩，作为第一张表
select b.kemu,max(b.score)as max_score
from grade b
group by kemu
# 再结合学生表和分数表，得到单科最好成绩
select c.id,a.name,c.kemu,c.score

from grade c,student a,
(select b.kemu,max(b.score)as max_score
from grade b
group by kemu) t
where c.kemu = t.kemu
and c.score = t.max_score
and a.id = c.id

```

#### 题目5：计算每个人的平均成绩， 要求显示字段: 学号，姓名，平均成绩
```
select a.id,a.name,c.avg_score
from student a,
(select b.id,avg(b.score) as avg_score 
from grade b
group by b.id)c
where a.id = c.id

```
